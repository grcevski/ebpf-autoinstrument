// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64
// +build 386 amd64

package nethttp

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type bpf_debugFuncInvocation struct {
	StartMonotimeNs uint64
	Regs            struct {
		R15     uint64
		R14     uint64
		R13     uint64
		R12     uint64
		Rbp     uint64
		Rbx     uint64
		R11     uint64
		R10     uint64
		R9      uint64
		R8      uint64
		Rax     uint64
		Rcx     uint64
		Rdx     uint64
		Rsi     uint64
		Rdi     uint64
		OrigRax uint64
		Rip     uint64
		Cs      uint64
		Eflags  uint64
		Rsp     uint64
		Ss      uint64
	}
	Sc struct {
		TraceID [16]uint8
		SpanID  [8]uint8
	}
}

type bpf_debugGoroutineMetadata struct {
	Parent    uint64
	Timestamp uint64
}

type bpf_debugTraceparentInfo struct{ Traceparent [55]uint8 }

// loadBpf_debug returns the embedded CollectionSpec for bpf_debug.
func loadBpf_debug() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Bpf_debugBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load bpf_debug: %w", err)
	}

	return spec, err
}

// loadBpf_debugObjects loads bpf_debug and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*bpf_debugObjects
//	*bpf_debugPrograms
//	*bpf_debugMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBpf_debugObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBpf_debug()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// bpf_debugSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_debugSpecs struct {
	bpf_debugProgramSpecs
	bpf_debugMapSpecs
}

// bpf_debugSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_debugProgramSpecs struct {
	UprobeServeHTTP           *ebpf.ProgramSpec `ebpf:"uprobe_ServeHTTP"`
	UprobeWriteHeader         *ebpf.ProgramSpec `ebpf:"uprobe_WriteHeader"`
	UprobeRoundTrip           *ebpf.ProgramSpec `ebpf:"uprobe_roundTrip"`
	UprobeRoundTripReturn     *ebpf.ProgramSpec `ebpf:"uprobe_roundTripReturn"`
	UprobeStartBackgroundRead *ebpf.ProgramSpec `ebpf:"uprobe_startBackgroundRead"`
	UprobeWriteSubset         *ebpf.ProgramSpec `ebpf:"uprobe_writeSubset"`
}

// bpf_debugMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_debugMapSpecs struct {
	Events                    *ebpf.MapSpec `ebpf:"events"`
	GolangMapbucketStorageMap *ebpf.MapSpec `ebpf:"golang_mapbucket_storage_map"`
	HeaderReqMap              *ebpf.MapSpec `ebpf:"header_req_map"`
	Newproc1                  *ebpf.MapSpec `ebpf:"newproc1"`
	OngoingGoroutines         *ebpf.MapSpec `ebpf:"ongoing_goroutines"`
	OngoingHttpClientRequests *ebpf.MapSpec `ebpf:"ongoing_http_client_requests"`
	OngoingServerRequests     *ebpf.MapSpec `ebpf:"ongoing_server_requests"`
	TempCharBuf               *ebpf.MapSpec `ebpf:"temp_char_buf"`
	TpInfos                   *ebpf.MapSpec `ebpf:"tp_infos"`
}

// bpf_debugObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpf_debugObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_debugObjects struct {
	bpf_debugPrograms
	bpf_debugMaps
}

func (o *bpf_debugObjects) Close() error {
	return _Bpf_debugClose(
		&o.bpf_debugPrograms,
		&o.bpf_debugMaps,
	)
}

// bpf_debugMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBpf_debugObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_debugMaps struct {
	Events                    *ebpf.Map `ebpf:"events"`
	GolangMapbucketStorageMap *ebpf.Map `ebpf:"golang_mapbucket_storage_map"`
	HeaderReqMap              *ebpf.Map `ebpf:"header_req_map"`
	Newproc1                  *ebpf.Map `ebpf:"newproc1"`
	OngoingGoroutines         *ebpf.Map `ebpf:"ongoing_goroutines"`
	OngoingHttpClientRequests *ebpf.Map `ebpf:"ongoing_http_client_requests"`
	OngoingServerRequests     *ebpf.Map `ebpf:"ongoing_server_requests"`
	TempCharBuf               *ebpf.Map `ebpf:"temp_char_buf"`
	TpInfos                   *ebpf.Map `ebpf:"tp_infos"`
}

func (m *bpf_debugMaps) Close() error {
	return _Bpf_debugClose(
		m.Events,
		m.GolangMapbucketStorageMap,
		m.HeaderReqMap,
		m.Newproc1,
		m.OngoingGoroutines,
		m.OngoingHttpClientRequests,
		m.OngoingServerRequests,
		m.TempCharBuf,
		m.TpInfos,
	)
}

// bpf_debugPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBpf_debugObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_debugPrograms struct {
	UprobeServeHTTP           *ebpf.Program `ebpf:"uprobe_ServeHTTP"`
	UprobeWriteHeader         *ebpf.Program `ebpf:"uprobe_WriteHeader"`
	UprobeRoundTrip           *ebpf.Program `ebpf:"uprobe_roundTrip"`
	UprobeRoundTripReturn     *ebpf.Program `ebpf:"uprobe_roundTripReturn"`
	UprobeStartBackgroundRead *ebpf.Program `ebpf:"uprobe_startBackgroundRead"`
	UprobeWriteSubset         *ebpf.Program `ebpf:"uprobe_writeSubset"`
}

func (p *bpf_debugPrograms) Close() error {
	return _Bpf_debugClose(
		p.UprobeServeHTTP,
		p.UprobeWriteHeader,
		p.UprobeRoundTrip,
		p.UprobeRoundTripReturn,
		p.UprobeStartBackgroundRead,
		p.UprobeWriteSubset,
	)
}

func _Bpf_debugClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed bpf_debug_bpfel_x86.o
var _Bpf_debugBytes []byte
